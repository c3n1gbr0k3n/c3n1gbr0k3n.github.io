<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FormatString on</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/formatstring/</link><description>Recent content in FormatString on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 11 Apr 2023 22:02:45 +0800</lastBuildDate><atom:link href="https://c3n1gbr0k3n.github.io/docs/exploit/formatstring/index.xml" rel="self" type="application/rss+xml"/><item><title>格式化字符串漏洞</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/formatstring/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</link><pubDate>Tue, 11 Apr 2023 22:02:30 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/formatstring/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</guid><description>0x01 介绍 # 格式化字符串格式 # 在学习C语言的时候，一般第一个学习的函数就是printf函数。它最常用的用法是通过格式化字符串来格式化输出内容，例如
printf(&amp;quot;%s&amp;quot;, buf); 但是也可以简单的写为
printf(buf); 这样也可以将buf字符串内容打印出来。但是这样做有个很大的风险，printf默认它的第一个参数中如果有格式化控制符则会进行解析，如果你对buf字符串输入了格式化控制符的话，这里就会出错，这个就是格式化字符串漏洞。
当我们往buf里输入格式化控制符的话，它会去找对应的参数进行解析，这里所谓的参数就是给printf的第一个之后的参数。但是我们简写的例子并没有给它第二个参数，它就会按照调用约定，自动认为后一个值为它的参数，然后我们可以利用格式化控制符对其进行操作。
在此之前我们需要详细的学习一下格式化控制符以及修饰符。
常用的格式化控制符有如下几个：
%d：有符号十进制
%u：无符号十进制
%x：十六进制整数
%s: 字符串
%p：指针格式
%n：将前面打印的字节数写入到给定指针指向的地方
#include&amp;lt;stdio.h&amp;gt; int main() { int a = 10; printf(&amp;quot;%d\n&amp;quot;, a); printf(&amp;quot;%x\n&amp;quot;, a); printf(&amp;quot;%p\n&amp;quot;, &amp;amp;a); // 打印的是a的地址 printf(&amp;quot;aaaa%n\n&amp;quot;, &amp;amp;a); // 写入变量a中 printf(&amp;quot;%d\n&amp;quot;, a); return 0; } 而修饰符有以下几个常用的：
宽度控制符，控制输出的宽度，形式为 %nd ，即输出n位宽度的字符串，如果不足则补空格右对齐
printf(&amp;quot;%4d&amp;quot;, 10); // 输出 &amp;quot; 10&amp;quot; 标志修饰符，控制输出的格式，常用的有以下几个
#：对于不同进制输出标志性字符
printf(&amp;quot;%#x&amp;quot;, 10); // 输出 &amp;quot;0xa&amp;quot; 0：用0填充输出的宽度不足的部分，只对数字类型有效
printf(&amp;quot;%04d&amp;quot;, 1); // 输出 &amp;quot;0001&amp;quot; -：左对齐输出</description></item><item><title>全局格式化字符串任意写</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/formatstring/%E5%85%A8%E5%B1%80%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99/</link><pubDate>Fri, 21 Apr 2023 22:46:04 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/formatstring/%E5%85%A8%E5%B1%80%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%BB%E6%84%8F%E5%86%99/</guid><description>0x01 介绍 # 之前的情况是格式化字符串保存在栈中，所以我们可以很容易控制栈的内容，往栈中写入地址等数据，但是如果格式化字符串是保存在bss、data段，那么我们就不能再通过之前的方式来实现任意写。之前任意写能实现就是因为在栈中有我们写入的地址，而现在我们不能对栈写入地址了。
我们来仔细观察栈中的数据
可以发现栈中保存了很多栈地址，如果我们可以通过任意写往这些栈地址指向的地方写入我们要攻击的地址，然后栈中就会出现被攻击的地址，最后我们再往被攻击的地址写入指定数据即可获取shell等操作
我们以一个例子来看
#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; char buf[0x50]; void hint() { system(&amp;quot;/bin/sh&amp;quot;); } int main() { int choice; setbuf(stdout, 0); while(1) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;choice); if(choice == 1) { scanf(&amp;quot;%s&amp;quot;, buf); printf(buf); } else { exit(0); } } } // gcc global_printf.c -m32 -o global_printf_x32 -no-pie 虽然原理按照之前的来将很简单，但是我们不能选简单的栈地址，而应该选栈链形式的地址，我们在之前讲任意写的时候是通过两次写入才完成的，因为我们不可以一次性写入很大的值，所以我们其实是需要中间有个地址过度，这个地址过度的目的是为了可以分两次来写入attack addr。我们可以控制过度地址的末尾的字节来修改stack addr的位置，从而达到分段写的目的。
我们以这个例子来具体讲操作。首先通过 0xffffd654 修改 0xffffd783 的后两个字节为离当前栈顶近的位置，再覆写之前需要先泄露一个地址，然后通过计算相对偏移量来获取设置后两个字节应该覆盖的地址，比如我们可以泄露图中第九个栈单元的 0xffffd5c0 ，而我们要写入的地址为 0xffffd5a8 ，泄露出来的地址和我们要写入地址之间的偏移量为0x18，payload就可以写为
stack = leak_addr - 0x18 # leak_addr为泄露出来的栈地址 payload = (&amp;quot;%{0}d%5$hn&amp;quot;.format(stack &amp;amp; 0xffff)).</description></item></channel></rss>