<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stackoverflow on</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/</link><description>Recent content in Stackoverflow on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 28 Mar 2023 22:48:58 +0800</lastBuildDate><atom:link href="https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/index.xml" rel="self" type="application/rss+xml"/><item><title>ret2text</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2text/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2text/</guid><description>0x01 介绍 # 栈是进程最常用到的内存类型之一，它具有高效和简单的特点，主要用来存储函数调用信息。通常来说32位的程序一个栈单元为4个字节，而64位程序一个栈单元为8个字节，然后多个栈单元可以组成一个 栈帧 ，栈帧的大小主要看函数信息的多少。一个栈单元通常包括以下几部分：
函数的参数，一般有父函数压入栈中 函数的返回地址，即函数执行完后ret跳转的地址 帧指针，即上一个栈帧的位置 局部变量，即函数内部声明的变量 栈有三大很重要的作用，同时也体现在栈帧结构里面了：
保存函数的局部变量 函数调用时传递参数 保存函数返回后的地址 而我们所有的栈溢出基本都是围绕着三大作用在进行，包括这里的ret2text题型。这种题型比较简单，它主要利用的是第三大功能，即函数返回地址，我们可以来看一个简单的程序的汇编代码
void main() { int a = 1; int b = 2; } // gcc -m32 test.c -o test -fno-pic -fno-stack-protector -no-pie 生成的汇编代码为
080483db &amp;lt;main&amp;gt;: 80483db: 55 push ebp 80483dc: 89 e5 mov ebp,esp 80483de: 83 ec 10 sub esp,0x10 80483e1: c7 45 fc 01 00 00 00 mov DWORD PTR [ebp-0x4],0x1 80483e8: c7 45 f8 02 00 00 00 mov DWORD PTR [ebp-0x8],0x2 80483ef: 90 nop 80483f0: c9 leave 80483f1: c3 ret 主要关注函数序言和函数尾声，在进入main函数之前，已经由父函数将main函数的返回地址给压入栈中，接着通过函数序言将帧指针压入栈中，并将帧指针的地址赋值给ebp，经过函数体后则进入函数尾声，尾声主要依靠 leave 指令，该指令相当于 mov esp, ebp;pop ebp ，当执行完该指令后当前栈顶就变为了main函数的返回地址，而 ret 指令的作用是跳转到当前栈顶存储的地址处继续执行（即修改eip为当前栈顶存储的那个值），这里也就是main函数的返回地址。</description></item><item><title>ret2syscall</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2syscall/</link><pubDate>Tue, 28 Mar 2023 21:07:32 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2syscall/</guid><description>0x01 介绍 # syscall又称为系统调用，是操作系统给用户的API接口，可以用来使用电脑资源。首先需要来熟悉系统调用的使用方式，对于32程序来说是通过 int 0x80 指令来执行系统调用，而64位程序则是通过 syscall 指令来执行。在执行命令前，需要把参数和系统调用号准备好，系统调用号是操作系统分配给不同系统调用的一个数字，以便内核区分它们，我们可以在 /usr/include/asm/unistd.h 找到32位和64位的系统调用号分别存储的文件
我们可以看一下32位的系统调用号
前部分是系统调用名称，比如 __NR_read 就是read系统调用，而后半部分就是系统调用号，都是数字，例如 3 就是read的系统调用号0。64位的系统调用号也是同理。
当执行内陷指令之前，需要将系统调用号传入ax寄存器中。其次需要在执行内陷指令前要做的就是传递参数给内核，这里不管是32位还是64位的程序都必须用寄存器来传递参数。对于32位来说，参数寄存器的传递顺序是 ebx、ecx、edx、esi、edi ，对于64位来说顺序为 rdi、rsi、rdx、rcx、r8、r9 。我们以内联汇编的形式来实现一个简单的系统调用
char *buf = &amp;quot;hello world\n&amp;quot;; void main(); asm( &amp;quot;.text\n&amp;quot; &amp;quot;.global main\n&amp;quot; &amp;quot;main:\n&amp;quot; // write(1, &amp;quot;hello world\n&amp;quot;, 12) &amp;quot;mov ebx, 1\n&amp;quot; // 第一个参数，标准输出流 &amp;quot;mov ecx, buf\n&amp;quot; // 第二个参数，字符串地址 &amp;quot;mov edx, 12\n&amp;quot; // 第三个参数，输出字节数 &amp;quot;mov eax, 4\n&amp;quot; // write的系统调用号 &amp;quot;int 0x80\n&amp;quot; // 内陷指令 ); // gcc test.c -o test -m32 -masm=intel 运行效果为</description></item></channel></rss>