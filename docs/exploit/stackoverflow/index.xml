<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>StackOverflow on</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/</link><description>Recent content in StackOverflow on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 28 Mar 2023 22:48:58 +0800</lastBuildDate><atom:link href="https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/index.xml" rel="self" type="application/rss+xml"/><item><title>ret2text</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2text/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2text/</guid><description>0x01 介绍 # 栈功能 # 栈是进程最常用到的内存类型之一，它具有高效和简单的特点，主要用来存储函数调用信息。通常来说32位的程序一个栈单元为4个字节，而64位程序一个栈单元为8个字节，然后多个栈单元可以组成一个 栈帧 ，栈帧的大小主要看函数信息的多少。一个栈单元通常包括以下几部分：
函数的参数，一般有父函数压入栈中 函数的返回地址，即函数执行完后ret跳转的地址 帧指针，即上一个栈帧的位置 局部变量，即函数内部声明的变量 栈有三大很重要的作用，同时也体现在栈帧结构里面了：
保存函数的局部变量 函数调用时传递参数 保存函数返回后的地址 而我们所有的栈溢出基本都是围绕着三大作用在进行，包括这里的ret2text题型。这种题型比较简单，它主要利用的是第三大功能，即函数返回地址，我们可以来看一个简单的程序的汇编代码
void main() { int a = 1; int b = 2; } // gcc -m32 test.c -o test -fno-pic -fno-stack-protector -no-pie 生成的汇编代码为
080483db &amp;lt;main&amp;gt;: 80483db: 55 push ebp 80483dc: 89 e5 mov ebp,esp 80483de: 83 ec 10 sub esp,0x10 80483e1: c7 45 fc 01 00 00 00 mov DWORD PTR [ebp-0x4],0x1 80483e8: c7 45 f8 02 00 00 00 mov DWORD PTR [ebp-0x8],0x2 80483ef: 90 nop 80483f0: c9 leave 80483f1: c3 ret 主要关注函数序言和函数尾声，在进入main函数之前，已经由父函数将main函数的返回地址给压入栈中，接着通过函数序言将帧指针压入栈中，并将帧指针的地址赋值给ebp，经过函数体后则进入函数尾声，尾声主要依靠 leave 指令，该指令相当于 mov esp, ebp;pop ebp ，当执行完该指令后当前栈顶就变为了main函数的返回地址，而 ret 指令的作用是跳转到当前栈顶存储的地址处继续执行（即修改eip为当前栈顶存储的那个值），这里也就是main函数的返回地址。</description></item><item><title>ret2syscall</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2syscall/</link><pubDate>Tue, 28 Mar 2023 21:07:32 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2syscall/</guid><description>0x01 介绍 # 系统调用 # syscall又称为系统调用，是操作系统给用户的API接口，可以用来使用电脑资源。首先需要来熟悉系统调用的使用方式，对于32程序来说是通过 int 0x80 指令来执行系统调用，而64位程序则是通过 syscall 指令来执行。在执行命令前，需要把参数和系统调用号准备好，系统调用号是操作系统分配给不同系统调用的一个数字，以便内核区分它们，我们可以在 /usr/include/asm/unistd.h 找到32位和64位的系统调用号分别存储的文件
我们可以看一下32位的系统调用号
前部分是系统调用名称，比如 __NR_read 就是read系统调用，而后半部分就是系统调用号，都是数字，例如 3 就是read的系统调用号0。64位的系统调用号也是同理。
当执行内陷指令之前，需要将系统调用号传入ax寄存器中。其次需要在执行内陷指令前要做的就是传递参数给内核，这里不管是32位还是64位的程序都必须用寄存器来传递参数。对于32位来说，参数寄存器的传递顺序是 ebx、ecx、edx、esi、edi ，对于64位来说顺序为 rdi、rsi、rdx、rcx、r8、r9 。我们以内联汇编的形式来实现一个简单的系统调用
char *buf = &amp;quot;hello world\n&amp;quot;; void main(); asm( &amp;quot;.text\n&amp;quot; &amp;quot;.global main\n&amp;quot; &amp;quot;main:\n&amp;quot; // write(1, &amp;quot;hello world\n&amp;quot;, 12) &amp;quot;mov ebx, 1\n&amp;quot; // 第一个参数，标准输出流 &amp;quot;mov ecx, buf\n&amp;quot; // 第二个参数，字符串地址 &amp;quot;mov edx, 12\n&amp;quot; // 第三个参数，输出字节数 &amp;quot;mov eax, 4\n&amp;quot; // write的系统调用号 &amp;quot;int 0x80\n&amp;quot; // 内陷指令 ); // gcc test.c -o test -m32 -masm=intel 运行效果为</description></item><item><title>ret2shellcode</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2shellcode/</link><pubDate>Thu, 30 Mar 2023 20:20:50 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2shellcode/</guid><description>0x01 介绍 # shellcode # ret2shellcode用到的知识也是系统调用，只不过和ret2syscall的区别在于后者是利用程序里已有的代码片段，而前者是需要自己写系统调用代码编译后注入到内存里，然后跳转到我们写入的地方来执行我们写入的代码，我们称这种代码为shellcode。这种题型的难点就在于shellcode编写，其他的和前面区别不大。最简单的shellcode即execve系统调用的写法为
获取 /bin/sh 字符串地址 将字符串地址赋值给第一个参数寄存器 将第二三参数寄存器置零 将系统调用号存入ax寄存器 执行内陷指令 32位的汇编代码为
push 0x0068732f push 0x6e69622f # &amp;quot;/bin/sh&amp;quot;字符串按照小端序压入到栈中 mov ebx, esp # 当前栈顶即esp指向的是&amp;quot;/bin/sh&amp;quot;字符串，将esp的值即字符串指针赋值给ebx xor ecx, ecx # ecx置零 xor edx, edx # edx置零 mov eax, 11 # 将execve系统调用号给eax int 0x80 # 执行系统调用 64位的汇编代码为
mov rax, 0x0068732f6e69622f push rax mov rdi, rsp xor rsi, rsi xor rdx, rdx mov rax, 59 syscall 值得注意的是64位不能直接将8个字节直接push进栈里，必须借助寄存器才可以将 /bin/sh 字符串压入栈中
ret2shellcode # 将汇编编译为机器码后注入到内存里即可。在此之前需要保存注入shellcode的地方有可执行权限，最常见的情况就是没有加 NX 保护，然后可以注入到堆栈、data段bss段。还有的情况就是使用mmap申请了一个有可执行权限的内存，例如</description></item><item><title>ret2libc</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2libc/</link><pubDate>Sun, 02 Apr 2023 00:49:42 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/ret2libc/</guid><description>0x01 介绍 # 动态链接 # 我们一般gcc编译不加 -static 的话默认就是动态链接，动态链接就是不将代码嵌入到你的程序中，而是等程序运行时再链接到动态链接库，从而减小程序的大小。我们可以对比以下动态和静态的区别
#include&amp;lt;stdio.h&amp;gt; int main() { puts(&amp;quot;hello world\n&amp;quot;); return 0; } // 动态链接: gcc test.c -o test // 静态链接: gcc test.c -o test_static -static 静态链接的话会把很多我们用不到的函数也给添加到程序中
静态编译的程序在内存中的布局为除了程序本身并没有其他的东西
而动态链接的话只有两个动态链接库的函数存留（而且保留的不是函数的代码，而是函数的符号）
在内存中的布局多了一个libc即动态链接库和ld链接器
相对而言的话，静态链接跳转执行函数的方式更简单点，因为地址都是确定的，直接跳转过去就可以执行。但是动态链接不行，因为动态链接库加载到内存中的地址是不固定的（有些情况下会固定，视情况而定），这就导致我们无法直接跳转到动态链接库中执行函数。动态链接库采用了一个名为 动态延迟绑定 的方法来解决这个问题的。动态延迟绑定简单解释就是只有当程序调用到需要的函数时程序才会去解析获取到函数的地址。这样一方面提高了程序的安全性（不知道函数的实际地址），另一方面也提高了效率（一些不需要的函数就不用解析出来）。动态延迟绑定主要和两个程序节有关，一个是 .plt ，还有一个是 .got.plt ，前者是过程链接表，当我们使用call指令调用函数的时候首先会跳转到 .plt 节
这里是puts函数的plt，它里面是一个跳转指令，跳转地址为puts函数的got表中存储的值（虽然程序中 .got 节也叫做全局偏移表，但是由于其只能在程序加载时固定值，并且之后都不可修改，不符合最新的安全性，所以弃用了，所以 .got.plt 可以直接称为got表）， .got.plt 称为全局偏移量表，在没有调用函数前其值初始化为plt表中的地址，这个地址 处的指令为上图的下一条地址的指令
push 0 的作用是把puts函数在got表中的位置压入栈中（这个位置其实是got表的第4个数据，在此之前还有三个数据是用来辅助解析地址的，默认保留），jmp指令则是跳转到plt中的一个代码段
第一个push是将 got表默认保留的第二个数据压入栈中，第二个数据是一个执行link_map结构体链的指针，每个link_map记录了一个动态链接库的信息。然后jmp指令会跳转到got表默认保留的第三个数据，这个数据是动态链接器 _dl_runtime_resolve() 的地址，经过动态链接器解析后，函数的got表就会被修改为其实际地址。之后再次调用该函数的时候就不会再次解析而是直接跳转到动态链接库中执行函数。
从以上可以得知plt表和got表的结构如下：
调用约定 # 知道了动态链接是怎么回事后再来看看如何调用这些函数的。这里就涉及到 调用约定 这个知识，调用约定是指在调用函数时如何传递参数、如何返回值以及如何进行栈帧的管理等一系列的约定。32位最常用的调用约定是 cdecl 调用约定，该调用约定指明参数从右往左依次压入栈中，返回值存入eax寄存器中，由调用者清理栈上的参数，例如我们写一个printf例子
printf(&amp;quot;%d, %d, %d\n&amp;quot;, 1, 2, 3); 生成的汇编为</description></item><item><title>Canary爆破</title><link>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/canary_blast/</link><pubDate>Thu, 01 Jun 2023 20:48:01 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/docs/exploit/stackoverflow/canary_blast/</guid><description>0x01 介绍 # Canary能够爆破的情况非常少，必要条件有两点：
多次触发stack smash 触发了stack smash也不会退出整个程序的运行 能实现这样条件的大概只有循环+fork子进程，fork函数可以创建一个和原进程一样的进程，然后原进程和这个新建的进程会同时执行接下来的代码。fork函数返回值有三种类型，第一种为0，即当前进程是子进程，第二种是大于0，表示当前进程为父进程，第三种为小于0表示fork失败。举个例子来说
#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;unistd.h&amp;gt; int main() { pid_t pid = fork(); // 子进程和父进程将会同时执行以下代码 if(pid == 0) { printf(&amp;quot;this is a child process\n&amp;quot;); } else if(pid &amp;gt; 0) { printf(&amp;quot;this is a father process\n&amp;quot;); } else { printf(&amp;quot;fork error\n&amp;quot;); } return 0; } // gcc fork_test.c -o fork_test pid等于0的情况和大于0的情况都会被运行到，对于子进程来说fork的返回值是0，而对于父进程来说fork的返回值是大于0的，然后子进程和父进程会并行运行，两种情况都会被打印出来。
子进程和父进程哪个先被执行是由操作系统调度决定的。了解了fork是如何运行的，接下来看一个典型的题目
#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;unistd.h&amp;gt; #include&amp;lt;sys/wait.h&amp;gt; void run() { char buf[0x10]; read(0, buf, 0x50); } int main() { pid_t pid; puts(&amp;quot;Canary blast&amp;quot;); while(1) { pid = fork(); if(pid &amp;gt; 0) { wait(0); // 等待子进程资源回收，即不执行父进程 } else if(pid == 0) { run(); puts(&amp;quot;done&amp;quot;); } else { break; } } return 0; } // gcc canary_blast.</description></item></channel></rss>