<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://c3n1gbr0k3n.github.io/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 06 Oct 2020 08:49:55 +0000</lastBuildDate><atom:link href="https://c3n1gbr0k3n.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>更新说明</title><link>https://c3n1gbr0k3n.github.io/blog/%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E/</link><pubDate>Fri, 21 Apr 2023 17:02:12 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/blog/%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E/</guid><description>2023.5.28 ~ 2023.6.3 # D # Canary爆破
栈迁移
B # 沙盒机制
2023.4.23 ~ 2023.4.29 # W # 2023阿里云CTF
2023.4.16 ~ 2023.4.22 # D # 全局格式化字符串任意写</description></item><item><title>Blog目录</title><link>https://c3n1gbr0k3n.github.io/blog/blog%E7%9B%AE%E5%BD%95/</link><pubDate>Thu, 30 Mar 2023 23:53:50 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/blog/blog%E7%9B%AE%E5%BD%95/</guid><description>目录 # 沙盒机制</description></item><item><title>沙盒机制</title><link>https://c3n1gbr0k3n.github.io/blog/%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/</link><pubDate>Sun, 21 May 2023 09:38:21 +0800</pubDate><guid>https://c3n1gbr0k3n.github.io/blog/%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/</guid><description>0x01 介绍 # 沙盒是计算机领域的虚拟技术，一般会将不信任的软件放入沙盒中运行，如果检测到软件的违规行为就会禁止程序进一步执行。这里的沙盒机制是针对于pwn题，由于程序运行最后都会通过系统调用来调用硬件资源，所以我们可以监控程序调用了哪些系统调用。如果程序执行了一些系统调用比如execve等，则直接end。 实现禁用系统调用的方法有两种，一种是通过prctl系统调用，还有一种是seccomp库
prctl系统调用 # 它的函数原型为
#include&amp;lt;sys/prctl.h&amp;gt; int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); option：要执行的操作标志 arg2、arg3、arg4、arg5：根据不同的操作标志有不同的参数 返回值：执行成功返回0，执行失败返回-1 option的值有很多，具体的可以查看Linux手册，这里比较常用的是PR_SET_NO_NEW_PRIVS（38）限制了新程序的特权，使其不能超过原程序的特权，只需要设置arg2为1即可
int prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); 还有一个值是PR_SET_SECCOMP（22），如果arg2为1的话，则表示只开启read、write、exit和sigreturn这几个系统调用。如果arg2为2的话则表示为过滤模式，主要根据arg3来过滤东西，arg3是一个struct sock_fprog类型指针，该结构体原型为
#include&amp;lt;linux/filter.h&amp;gt; struct sock_fprog { unsigned short len; struct sock_filter *filter; }; len：表示过滤器个数 filter：指向过滤器的指针，指向sock_filter数组 sock_filter结构体原型为
struct sock_filter { /* Filter block */ __u16 code; /* Actual filter code */ __u8 jt; /* Jump true */ __u8 jf; /* Jump false */ __u32 k; /* Generic multiuse field */ }; code：指令码，即该指令的操作类型和参数类型 jt：表示跳转条件，即如果该指令的操作结果为真，应该跳转到哪个指令执行 jf：表示跳转条件，即如果该指令的操作结果为假，应该跳转到哪个指令执行 k：表示参数，即该指令的操作参数 常见的code有</description></item></channel></rss>